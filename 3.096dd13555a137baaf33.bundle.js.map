{"version":3,"file":"3.096dd13555a137baaf33.bundle.js","sources":["webpack:///./node_modules/jellyschema/jellyschema.js"],"sourcesContent":["import * as wasm from './jellyschema_bg';\n\nconst heap = new Array(32);\n\nheap.fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* Generates JSON and UI schema object\n*\n* ```js\n* {\n    *     \\\"jsonSchema\\\": {...},\n    *     \\\"uiSchema\\\": {...}\n    * }\n    * ```\n    *\n    * # Arguments\n    *\n    * * `schema` - Jelly Schema as an object or a string\n    *\n    * # Throws\n    *\n    * If the input schema is invalid or in case of internal error (serialization).\n    * @param {any} arg0\n    * @returns {any}\n    */\n    export function generateJsonAndUiSchema(arg0) {\n        try {\n            return takeObject(wasm.generateJsonAndUiSchema(addBorrowedObject(arg0)));\n\n        } finally {\n            heap[stack_pointer++] = undefined;\n\n        }\n\n    }\n\n    /**\n    * @param {any} arg0\n    * @param {any} arg1\n    * @param {boolean} arg2\n    * @returns {any}\n    */\n    export function fillDefaultValues(arg0, arg1, arg2) {\n        try {\n            return takeObject(wasm.fillDefaultValues(addBorrowedObject(arg0), addBorrowedObject(arg1), arg2));\n\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n\n        }\n\n    }\n\n    let cachedTextDecoder = new TextDecoder('utf-8');\n\n    let cachegetUint8Memory = null;\n    function getUint8Memory() {\n        if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n            cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n        }\n        return cachegetUint8Memory;\n    }\n\n    function getStringFromWasm(ptr, len) {\n        return cachedTextDecoder.decode(getUint8Memory().subarray(ptr, ptr + len));\n    }\n\n    export function __wbg_error_4bb6c2a97407129a(arg0, arg1) {\n        let varg0 = getStringFromWasm(arg0, arg1);\n\n        varg0 = varg0.slice();\n        wasm.__wbindgen_free(arg0, arg1 * 1);\n\n        console.error(varg0);\n    }\n\n    function addHeapObject(obj) {\n        if (heap_next === heap.length) heap.push(heap.length + 1);\n        const idx = heap_next;\n        heap_next = heap[idx];\n\n        heap[idx] = obj;\n        return idx;\n    }\n\n    export function __wbg_new_59cb74e423758ede() {\n        return addHeapObject(new Error());\n    }\n\n    let cachedTextEncoder = new TextEncoder('utf-8');\n\n    let WASM_VECTOR_LEN = 0;\n\n    let passStringToWasm;\n    if (typeof cachedTextEncoder.encodeInto === 'function') {\n        passStringToWasm = function(arg) {\n\n            let size = arg.length;\n            let ptr = wasm.__wbindgen_malloc(size);\n            let writeOffset = 0;\n            while (true) {\n                const view = getUint8Memory().subarray(ptr + writeOffset, ptr + size);\n                const { read, written } = cachedTextEncoder.encodeInto(arg, view);\n                arg = arg.substring(read);\n                writeOffset += written;\n                if (arg.length === 0) {\n                    break;\n                }\n                ptr = wasm.__wbindgen_realloc(ptr, size, size * 2);\n                size *= 2;\n            }\n            WASM_VECTOR_LEN = writeOffset;\n            return ptr;\n        };\n    } else {\n        passStringToWasm = function(arg) {\n\n            const buf = cachedTextEncoder.encode(arg);\n            const ptr = wasm.__wbindgen_malloc(buf.length);\n            getUint8Memory().set(buf, ptr);\n            WASM_VECTOR_LEN = buf.length;\n            return ptr;\n        };\n    }\n\n    let cachegetUint32Memory = null;\n    function getUint32Memory() {\n        if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {\n            cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n        }\n        return cachegetUint32Memory;\n    }\n\n    export function __wbg_stack_558ba5917b466edd(ret, arg0) {\n\n        const retptr = passStringToWasm(getObject(arg0).stack);\n        const retlen = WASM_VECTOR_LEN;\n        const mem = getUint32Memory();\n        mem[ret / 4] = retptr;\n        mem[ret / 4 + 1] = retlen;\n\n    }\n\n    export function __wbg_getTime_ece6079ef900687a(arg0) {\n        return getObject(arg0).getTime();\n    }\n\n    export function __wbg_new0_7a2568f251003178() {\n        return addHeapObject(new Date());\n    }\n\n    export function __wbg_new_c485e81233f857dc(arg0, arg1) {\n        let varg0 = getStringFromWasm(arg0, arg1);\n        return addHeapObject(new Function(varg0));\n    }\n\n    export function __wbg_call_5dd2903e2041df91(arg0, arg1) {\n        return addHeapObject(getObject(arg0).call(getObject(arg1)));\n    }\n\n    export function __wbg_self_593d5fcdf47729c1(arg0) {\n        return addHeapObject(getObject(arg0).self);\n    }\n\n    export function __wbg_crypto_0255f439f7c7cf2e(arg0) {\n        return addHeapObject(getObject(arg0).crypto);\n    }\n\n    export function __wbg_getRandomValues_00289894188ac3d8(arg0) {\n        return addHeapObject(getObject(arg0).getRandomValues);\n    }\n\n    function getArrayU8FromWasm(ptr, len) {\n        return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);\n    }\n\n    export function __wbg_getRandomValues_957b4e930554e3a0(arg0, arg1, arg2) {\n        let varg1 = getArrayU8FromWasm(arg1, arg2);\n        getObject(arg0).getRandomValues(varg1);\n    }\n\n    export function __wbg_require_1d9cd4e0b19bc7a1(arg0, arg1) {\n        let varg0 = getStringFromWasm(arg0, arg1);\n        return addHeapObject(require(varg0));\n    }\n\n    export function __wbg_randomFillSync_516d812ff22b7f58(arg0, arg1, arg2) {\n        let varg1 = getArrayU8FromWasm(arg1, arg2);\n        getObject(arg0).randomFillSync(varg1);\n    }\n\nexport function __wbindgen_string_new(p, l) { return addHeapObject(getStringFromWasm(p, l)); }\n\nexport function __wbindgen_is_undefined(i) { return getObject(i) === undefined ? 1 : 0; }\n\nexport function __wbindgen_is_string(i) { return typeof(getObject(i)) === 'string' ? 1 : 0; }\n\nexport function __wbindgen_string_get(i, len_ptr) {\n    let obj = getObject(i);\n    if (typeof(obj) !== 'string') return 0;\n    const ptr = passStringToWasm(obj);\n    getUint32Memory()[len_ptr / 4] = WASM_VECTOR_LEN;\n    return ptr;\n}\n\nexport function __wbindgen_json_parse(ptr, len) { return addHeapObject(JSON.parse(getStringFromWasm(ptr, len))); }\n\nexport function __wbindgen_json_serialize(idx, ptrptr) {\n    const ptr = passStringToWasm(JSON.stringify(getObject(idx)));\n    getUint32Memory()[ptrptr / 4] = ptr;\n    return WASM_VECTOR_LEN;\n}\n\nexport function __wbindgen_jsval_eq(a, b) { return getObject(a) === getObject(b) ? 1 : 0; }\n\nexport function __wbindgen_rethrow(idx) { throw takeObject(idx); }\n\nexport function __wbindgen_throw(ptr, len) {\n    throw new Error(getStringFromWasm(ptr, len));\n}\n\nfunction freeJellySchema(ptr) {\n\n    wasm.__wbg_jellyschema_free(ptr);\n}\n/**\n*/\nexport class JellySchema {\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        freeJellySchema(ptr);\n    }\n\n    /**\n    * Instantiates new JellySchema object\n    *\n    * # Arguments\n    *\n    * * `schema` - JellySchema as a string or an object\n    *\n    * # Throws\n    *\n    * Constructor throws in case of invalid `schema` argument value.\n    * @param {any} arg0\n    * @returns {}\n    */\n    constructor(arg0) {\n        try {\n            this.ptr = wasm.jellyschema_constructor(addBorrowedObject(arg0));\n\n        } finally {\n            heap[stack_pointer++] = undefined;\n\n        }\n\n    }\n    /**\n    * Fills missing `default` values\n    *\n    * # Arguments\n    *\n    * * `data` - JSON value (string, object, array, ...)\n    * * `include_optional` - if `false` only required properties are filled in otherwise\n    *                        optional properties are filled too\n    * @param {any} arg0\n    * @param {boolean} arg1\n    * @returns {any}\n    */\n    fillDefaultValues(arg0, arg1) {\n        try {\n            return takeObject(wasm.jellyschema_fillDefaultValues(this.ptr, addBorrowedObject(arg0), arg1));\n\n        } finally {\n            heap[stack_pointer++] = undefined;\n\n        }\n\n    }\n    /**\n    * Validates data against JellySchema\n    *\n    * # Arguments\n    *\n    * * `data` - A JSON object\n    * @param {any} arg0\n    * @returns {boolean}\n    */\n    validate(arg0) {\n        try {\n            return (wasm.jellyschema_validate(this.ptr, addBorrowedObject(arg0))) !== 0;\n\n        } finally {\n            heap[stack_pointer++] = undefined;\n\n        }\n\n    }\n    /**\n    * Generates JSON Schema & UI Schema object\n    *\n    * ```js\n    * {\n        *     \\\"jsonSchema\\\": {...},\n        *     \\\"uiSchema\\\": {...}\n        * }\n        * ```\n        *\n        * # Throws\n        *\n        * In case of internal error only (serialization).\n        * @returns {any}\n        */\n        jsonAndUiSchema() {\n            return takeObject(wasm.jellyschema_jsonAndUiSchema(this.ptr));\n        }\n        /**\n        * Returns last validation errors\n        *\n        * # Throws\n        *\n        * In case of internal error only (serialization).\n        * @returns {any}\n        */\n        errors() {\n            return takeObject(wasm.jellyschema_errors(this.ptr));\n        }\n    }\n\nexport function __wbindgen_object_drop_ref(i) { dropObject(i); }\n\n"],"mappings":"AAAA","sourceRoot":""}